
我们前面举的例子（[112-矩阵旋转、平移与齐次坐标](112-矩阵旋转、平移与齐次坐标.md)）是对**一个二维点**（即形如 N×1 的列向量）使用旋转/平移操作。但你的问题进一步深入了实际应用：

> 如果我有一个二维矩阵（比如图像、表格）是 M×N 的，这样的“矩阵”能否用齐次坐标进行旋转和平移？

答案是：**可以，但方式稍有不同**。我们需要区分清楚**两个层面**：

---

# 1 **一、两种“矩阵”的含义（关键点）**

|**类型**|**表示含义**|**变换对象**|**使用方式**|
|---|---|---|---|
|向量矩阵（N×1）|单个点|点的坐标|可以直接乘变换矩阵|
|图像矩阵（M×N）|数据场（如像素）|所有点的坐标位置|每个点的位置需要被变换（坐标被旋转）|

所以对 M×N 的矩阵（如图像）进行旋转平移时，**不是直接拿变换矩阵乘它本身**，而是：

> **变换它的坐标系（每个像素点的位置）**，再通过**插值**将原矩阵的值“搬到”新坐标位置上。

---

# 2 **二、举个例子：一个M×N图像的旋转**

假设你有一个矩阵：

```
A = [[1, 2, 3],
     [4, 5, 6],
     [7, 8, 9]]
```

你想把它逆时针旋转 90°，如果你尝试做：

```
R @ A   # ❌ 错误！维度不对，语义也不对
```

这是错误的做法。

正确的做法是：
1. 遍历输出矩阵中每个目标位置 (x', y')
2. 用**反向仿射变换**（平移 + 旋转）求出它在原始图像中的位置 (x, y)
3. 用插值（最近邻、双线性）获取 (x, y) 对应值，赋值给新矩阵的 (x', y')

  

这个过程用**仿射变换矩阵（齐次坐标）**即可统一表示：
$T = \begin{bmatrix} \cos\theta & -\sin\theta & t_x \\ \sin\theta & \cos\theta & t_y \\ 0 & 0 & 1 \end{bmatrix}$

然后你对每一个目标坐标 $[x', y', 1]$，做：

$[x, y, 1]^T = T^{-1} \cdot [x’, y’, 1]^T$

你得到了原图上的位置，再插值赋值。

---

# 3 **三、为什么不能直接T × A？**

因为你的矩阵 A 是**像素值**，不是一堆坐标点。
举个比喻：
- A 是一个表格，里面每个格子有一个值
- T 是变换规则（怎么移动格子）
- 你不能直接拿规则去“乘”表格，而是要遍历格子，**搬运值到新位置**

---

# 4 **四、实际工程怎么做？**

比如在图像处理中，可以这么操作（以 NumPy 和 OpenCV 为例）：

```
import cv2
import numpy as np

image = np.array([
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
], dtype=np.uint8)

旋转中心为图像中心
(h, w) = image.shape
center = (w // 2, h // 2)

构造旋转矩阵（注意是2x3仿射矩阵）
M = cv2.getRotationMatrix2D(center=center, angle=90, scale=1.0)

应用仿射变换
rotated = cv2.warpAffine(image, M, (w, h))

print(rotated)
```

这里的 getRotationMatrix2D 返回的是简化的仿射变换矩阵（其实是 3x3 的前两行），warpAffine 就是对每个坐标点用你定义的旋转+平移进行变换。

---

# 5 **五、总结**

- **旋转向量**：直接使用旋转矩阵左乘即可。
- **旋转矩阵（图像/表格）**：实际上是变换每个点的位置坐标，搬运数据，不能直接乘。
- **齐次坐标的作用**：统一表达了“旋转 + 平移”等复合变换，适用于批量变换坐标点。
- 实际图像旋转处理要结合**反向映射 + 插值**实现。