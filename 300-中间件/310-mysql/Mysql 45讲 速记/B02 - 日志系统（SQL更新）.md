+ redo log：
	+ InnoDB特有的日志
	+ InnoDB存储引擎实现事务持久性的重要机制之一
+ binlog：
	+ Server层日志，又称归档日志
+ WAL技术（课外扩展）
+ 一条update语句执行核心流程：
	+ 取数据
		+ 如果在内存中，重内存中返回
		+ 否则从磁盘中读入内存
	+ 更新数据（值更新后，写入新行）
		+ **如何写入**
			+ 更新至内存
			+ 写入redolog（写入后，处于prepare阶段）
			+ 写入binlog
			+ 提交事物（commit状态）
# 1 引入

```
mysql> create table T(ID int primary key, c int);
mysql> update T set c=c+1 where ID=2;
```
上面的更新语句执行流程和 [B01 - SQL执行基础框架](B01%20-%20SQL执行基础框架.md)中的框架图一致。
不一样的地方是：更新前，会将表相关的查询缓存失效。

与查询流程不一样的是，更新流程还涉及两个重要的日志模块：**redo log**（重做日志）和 **binlog**（归档日志）

# 2 redo log
有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 crash-safe。
InnoDB引擎特有的日志

## 2.1 概念的引入

不知道你还记不记得《孔乙己》这篇文章，酒店掌柜有一个粉板，专门用来记录客人的赊账记录。如果赊账的人不多，那么他可以把顾客名和账目写在板上。但如果赊账的人多了，粉板总会有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的账本。

如果有人要赊账或者还账的话，掌柜一般有两种做法：
+ 一种做法是直接把账本翻出来，把这次赊的账加上去或者扣除掉；
+ **另一种做法是先在粉板上记下这次的账，等打烊以后再把账本翻出来核算**。

在生意红火柜台很忙时，掌柜一定会选择后者，因为前者操作实在是太麻烦了。首先，你得找到这个人的赊账总额那条记录。你想想，密密麻麻几十页，掌柜要找到那个名字，可能还得带上老花镜慢慢找，找到之后再拿出算盘计算，最后再将结果写回到账本上。
这整个过程想想都麻烦。相比之下，还是先在粉板上记一下方便。你想想，如果掌柜没有粉板的帮助，每次记账都得翻账本，效率是不是低得让人难以忍受？

*同样，在 MySQL 里也有这个问题，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。*

为了解决这个问题，MySQL 的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。而粉板和账本配合的整个过程，其实就是 MySQL 里经常说到的 **WAL** 技术，WAL 的全称是 Write-Ahead Logging，它的关键点就是**先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本**。

具体来说，
+ 当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log（粉板）里面，并更新内存，这个时候更新就算完成了。
+ 同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。
如果今天赊账的不多，掌柜可以等打烊后再整理。但如果某天赊账的特别多，粉板写满了，又怎么办呢？这个时候掌柜只好放下手中的活儿，把粉板中的一部分赊账记录更新到账本中，然后把这些记录从粉板上擦掉，为记新账腾出空间。
与此类似，InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。

![](img/Pasted%20image%2020240804114150.png)

write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。
write pos 和 checkpoint 之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果 write pos 追上 checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。
**有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 crash-safe**。
要理解 crash-safe 这个概念，可以想想我们前面赊账记录的例子。只要赊账记录记在了粉板上或写在了账本上，之后即使掌柜忘记了，比如突然停业几天，恢复生意后依然可以通过账本和粉板上的数据明确赊账账目。
## 2.2 专业描述
MySQL的redo log（重做日志）是InnoDB存储引擎实现事务持久性的重要机制之一。它用于记录对数据的所有更改，以确保在数据库崩溃或异常关闭时能够恢复数据。以下是关于redo log的详细介绍：
### 2.2.1 作用和特点
- **持久性**：确保在事务提交后，数据的更改被持久化，即使系统崩溃也能恢复。
- **崩溃恢复**：在数据库重启时，redo log会应用未完成的事务以恢复数据。
- **性能优化**：通过先写日志再写数据的方式，减少磁盘I/O，提高性能。
### 2.2.2 工作原理
- **WAL机制**：MySQL采用Write-Ahead Logging（先写日志）机制，事务中的更改先记录到redo log，然后再应用到数据页。
- **日志文件组**：redo log由一组文件组成，通常称为“日志文件组”，这些文件按照循环写入的方式工作。
- **LSN（Log Sequence Number）**：每次写入redo log时都会生成一个递增的LSN，用于标识日志记录的顺序。

### 2.2.3 组成部分
- **redo log buffer**：内存中的缓冲区，用于暂存redo log的内容。
- **redo log files**：磁盘上的日志文件，用于持久化保存redo log。

### 2.2.4 写入过程
1. **事务开始**：事务开始时，InnoDB会分配一个新的LSN。
2. **生成日志**：事务执行过程中，对数据页的修改会生成相应的redo log记录。
3. **写入缓冲区**：这些日志记录首先写入redo log buffer。
4. **写入磁盘**：当事务提交时，InnoDB会将redo log buffer中的内容刷新到磁盘上的redo log files中。

### 2.2.5 恢复过程
- **分析阶段**：数据库重启时，InnoDB会从redo log文件中分析未完成的事务。
- **重做阶段**：应用redo log中的更改，将未完成的事务提交，恢复数据一致性。

### 2.2.6 参数配置
- **innodb_log_file_size**：设置每个redo log文件的大小。
- **innodb_log_files_in_group**：设置redo log文件组中的文件数量。
- **innodb_flush_log_at_trx_commit**：控制事务提交时redo log的刷新行为。

### 2.2.7 示例配置
通过合理配置和使用redo log，MySQL能够在保证数据一致性和持久性的同时，提供高效的性能表现。
```sql
-- 设置redo log文件大小为128MB
SET GLOBAL innodb_log_file_size = 134217728;

-- 设置redo log文件组的文件数量为3
SET GLOBAL innodb_log_files_in_group = 3;

-- 设置事务提交时立即刷新redo log到磁盘
SET GLOBAL innodb_flush_log_at_trx_commit = 1;
```


# 3 binlog
## 3.1 概念引入
### 3.1.1 与redo log区别
1. redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。
2. **redo log 是物理日志**，记录的是“在某个数据页上做了什么修改”；**binlog 是逻辑日志**，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。
3. redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。
### 3.1.2 update语句对应的内部流程
1. 执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。
2. 执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。
3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。
4. 执行器生成这个操作的 binlog，并把 binlog 写入磁盘。
5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。
这里我给出这个 update 语句的执行流程图，图中浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的。
![](img/Pasted%20image%2020240804122246.png)
你可能注意到了，最后三步看上去有点“绕”，将 redo log 的写入拆成了两个步骤：prepare 和 commit，这就是"**两阶段提交**"。

### 3.1.3 binlog如何恢复数据库的
为什么必须有“两阶段提交”呢？这是为了让两份日志之间的逻辑一致。要说明这个问题，我们得从文章开头的那个问题说起：**怎样让数据库恢复到半个月内任意一秒的状态**？
前面我们说过了，binlog 会记录所有的逻辑操作，并且是采用“追加写”的形式。如果你的 DBA 承诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有 binlog，同时系统会定期做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。
当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做：首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库；然后，从备份的时间点开始，将备份的 binlog 依次取出来，重放到中午误删表之前的那个时刻。
这样你的临时库就跟误删之前的线上库一样了，然后你可以把表数据从临时库取出来，按需要恢复到线上库去。
### 3.1.4 两阶段提交

#### 3.1.4.1 为何要两阶段提交（反正法）
存在的必要性，用反证法来阐述。。。。

由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完 redo log 再写 binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。
仍然用前面的 update 语句来做例子。假设当前 ID=2 的行，字段 c 的值是 0，再假设执行 update 语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了 crash，会出现什么情况呢？

1. **先写 redo log 后写 binlog**。假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。
2. **先写 binlog 后写 redo log**。如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。