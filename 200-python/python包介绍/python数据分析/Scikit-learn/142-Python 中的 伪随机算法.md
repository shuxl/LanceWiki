Python 中的 **伪随机算法**，是通过确定性的数学公式来生成“看起来像随机数”的数列，这种算法在计算机中被广泛用于模拟随机行为。
#算法/伪随机 

---
# 1 伪随机介绍
## 1.1 **🧠 一、什么是“伪随机”？**

- **随机数** 是不可预测的，来源通常是自然界（比如硬件采样、鼠标移动等）；
- **伪随机数（Pseudo-Random Numbers）** 是用一个公式生成的数列，**虽然是确定性的，但表现得像是随机的**。

特点：

|**特性**|**描述**|
|---|---|
|决定性|同一个初始值（种子）下，生成的数列总是相同的|
|可复现|非常适合调试、模拟实验|
|分布性|通常符合均匀分布、正态分布等统计性质|
|速度快|基于数学算法而非物理随机源，计算效率高|

---

## 1.2 **🛠 二、Python 中的伪随机算法实现**

Python 中使用的伪随机算法，主要依赖标准库 random。它底层用的是：
### 1.2.1 **✅ Mersenne Twister 算法（梅森旋转算法）**

- 是一种 **高质量伪随机数生成器**（PRNG）；
- 周期非常长（2²⁰⁰⁰⁰ - 1），足以模拟各种“随机”行为；
- 实现了**均匀分布、正态分布、贝塔分布、伽马分布等各种随机函数**。

示例代码：

```
import random

random.seed(42)  # 设置种子，保证复现性
print(random.random())  # 生成一个0~1之间的伪随机浮点数
print(random.randint(1, 10))  # 生成一个1~10之间的伪随机整数
```

---

## 1.3 **🧮 三、背后的算法逻辑（以 Mersenne Twister 为例）**

  
Mersenne Twister 的基本思想是：
1. 使用一个 **状态数组**（例如 624 个整数）作为内部状态；
2. 每次用状态数组中某些值按特定方式混合生成新的随机值；
3. 每生成 624 个值，就重新“搅拌”状态数组；
4. 生成的数再通过一些位运算进行“变形”，增强分布性。

关键点：

|**步骤**|**说明**|
|---|---|
|初始化|用种子值构造一个初始状态数组|
|混合变换|每次根据状态数组生成新的伪随机值|
|抽样分布|可以映射为不同的概率分布（均匀、正态等）|
|可重复性|设置相同的种子即可重复相同的随机序列|

---

## 1.4 **🔄 四、种子（Seed）机制**

种子就是“随机数序列的起点”，决定整个伪随机序列的内容。
```
random.seed(123)  # 给定种子值
print(random.random())  # 多次运行，结果始终相同
```

- **用途：**
    - 模型复现实验
    - 游戏调试复现bug
    - 可控性测试
- **注意：**
    - 不设种子则默认用系统时间，表现为“真随机”（但实际上仍是伪随机）

---

## 1.5 **📦 五、替代方案：真正的随机（不可预测）**

Python 的 secrets 模块专门用于生成**安全随机数**（如密码、令牌）：
```
import secrets
print(secrets.randbelow(100))  # 安全的随机整数
print(secrets.token_hex(16))   # 生成安全的随机 token
```
它底层依赖操作系统的“熵源”（如 /dev/urandom），不可预测。

---

## 1.6 **✅ 总结**

| **项目** | random **模块**    | secrets **模块** |
| ------ | ---------------- | -------------- |
| 是否伪随机  | 是                | 否（加密安全）        |
| 可重复性   | 可设置种子            | 不可             |
| 适用场景   | 模拟、游戏、实验         | 密码学、令牌生成       |
| 底层算法   | Mersenne Twister | 系统熵源           |


# 2 伪随机分类
在计算机科学中，**伪随机数生成器（PRNG, Pseudo-Random Number Generator）**有多种实现方式，不同方法的原理、效率、周期长度、统计性质各有不同。下面是几类常见的伪随机算法及代表实现：

---

## 2.1 **🧠 一、主流的伪随机数生成算法**

| **类别** | **名称**                                                    | **特点**   | **周期长度**                | **是否常用于现代系统**   |
| ------ | --------------------------------------------------------- | -------- | ----------------------- | --------------- |
| 1      | **线性同余法（LCG）**                                            | 最简单、古老   | 最多 $2^{32}$ 或 $2^{64}$  | ✅ 初学、嵌入式        |
| 2      | **梅森旋转法（Mersenne Twister）**                               | 高质量、长周期  | $2^{19937} - 1$         | ✅ Python、C++ 默认 |
| 3      | **Xorshift**                                              | 快速、结构简单  | $2^{128}$ ~ $2^{1024}$  | ✅ 游戏/轻量应用       |
| 4      | **PCG（Permuted Congruential Generator）**                  | 新一代、分布更好 | $2^{64}$ ~ $2^{128}$    | ✅ Rust、C++ 推荐   |
| 5      | **WELL（Well Equidistributed Long-period Linear）**         | 改进版MT    | $2^{512}$ ~ $2^{19937}$ | ✅ 一些科学应用        |
| 6      | **Blum Blum Shub**                                        | 加密级安全    | 非常大                     | ❌ 慢，安全领域使用      |
| 7      | **ISAAC（Indirection, Shift, Accumulate, Add, and Count）** | 密码学安全    | 很大                      | ❌ 专用安全领域        |
| 8      | **SecureRandom / CryptGenRandom**                         | 操作系统安全源  | 不可预测                    | ✅ 密码安全用途        |
| 9      | **加密算法伪随机（AES/ChaCha-based PRNG）**                        | 安全、复杂    | 不可穷尽                    | ✅ 密钥生成等         |

---

## 2.2 **🧮 二、每种类型简要解释**

### 2.2.1 **线性同余法 LCG（Linear Congruential Generator）**

```
Xₙ₊₁ = (a * Xₙ + c) mod m
```

- 参数：a、c、m 需选得当
- 简单易实现，但高位随机性差
- 适用于教学和非关键应用
    

---

### 2.2.2 **Mersenne Twister（梅森旋转）**
- 名称来自梅森素数：周期 $2^{19937}-1$
- 使用 624 个状态位混合生成随机数
- 高效、统计性质好
- Python 的 random 模块默认使用它

---

### 2.2.3 **Xorshift / Xoroshiro / Xoshiro**
- 基于移位和异或，结构简单
- 极快，适合嵌入式、游戏
- 分布和周期优于 LCG，但不适合加密用途
    

---

### 2.2.4 **PCG（Permuted Congruential Generator）**
- 现代 PRNG，提供更均匀的分布
- 支持多线程、可移植性强
- 推荐作为 Mersenne Twister 的替代方案

---

### 2.2.5 **WELL（Well Equidistributed Long-period Linear）**

- 改进 Mersenne Twister，在某些维度下更均匀
- 用于数值模拟和科学计算

---

### 2.2.6 **Blum Blum Shub（BBS）**

```
Xₙ₊₁ = Xₙ² mod M（M 为两个大素数的乘积）
```
- 极难预测，适合密码学
- 非常慢，不适合常规用途

---

### 2.2.7 **ISAAC**

- 适用于高安全性场景，如加密通信
- 分布很好，但实现复杂
    

---

### 2.2.8 ### 2.2.9 **系统安全源：SecureRandom / os.urandom / secrets**
- 不可预测，基于系统熵池（如 Linux 的 /dev/urandom）
- 用于生成密码、密钥、令牌等
    

---

### 2.2.9 基于加密算法的 PRNG**

- 使用对称加密算法（如 AES 或 ChaCha20）生成随机序列
- 强加密安全性，适合加密协议、TLS、JWT等

---

## 2.3 **✅ 三、分类总结**

|**类型**|**举例**|**是否可预测**|**用途**|
|---|---|---|---|
|基础型|LCG, Xorshift|✅ 可预测|游戏、算法教学|
|高质量模拟型|MT, WELL, PCG|✅ 可预测|科学计算、模拟|
|加密安全型|BBS, ISAAC, SecureRandom|❌ 不可预测|密码学、令牌、安全通信|
|混合型|AES-PRNG, ChaCha-PRNG|❌ 不可预测|高性能 + 安全场景|

---

## 2.4 **📌 结语**

- **如果你做普通模拟、数据分析、随机打乱，用 random 就够了。**
- **如果做安全、密码、认证，请用 secrets 或操作系统熵源。**
- **如果研究底层实现，可以从 LCG 或 Xorshift 入门写一个自己的 PRNG。**

# 3 LCG的python例子（最简单的伪随机）
好的，我们从最简单的伪随机数生成器 —— **线性同余生成器（LCG）** 入手，用 Python 写一个小例子，非常适合学习理解。

---

## 3.1 **🧠 LCG 的公式**
$X_{n+1} = (a \cdot X_n + c) \mod m$

其中：
- X_0 是种子（seed）
- a、c、m 是参数：
    - a：乘数
    - c：增量
    - m：模数

---

## 3.2 **✅ Python 实现**

我们写一个类 LCG 来实现它：

```
class LCG:
    def __init__(self, seed=1, a=1664525, c=1013904223, m=2**32):
        self.a = a
        self.c = c
        self.m = m
        self.state = seed

    def next(self):
        self.state = (self.a * self.state + self.c) % self.m
        return self.state

    def random(self):
        """返回 [0, 1) 之间的浮点数"""
        return self.next() / self.m
```

---

## 3.3 **🧪 使用示例**

```
lcg = LCG(seed=42)

# 生成前10个随机整数
print("随机整数序列：")
for _ in range(10):
    print(lcg.next())

# 生成前5个随机小数（0~1之间）
print("\n0~1之间的随机数：")
for _ in range(5):
    print(lcg.random())
```

---

## 3.4 **💡 输出示例（部分）：**

```
随机整数序列：
1083814273
378494188
2479403867
955863294
...
0~1之间的随机数：
0.25229653580868244
0.08816853977367282
...
```

---

## 3.5 **📌 总结**

这个例子中我们实现了一个简单的伪随机数生成器，它的行为具有以下特点：
- 每次调用 .next() 返回一个新的伪随机整数；
- .random() 把它归一化成 \[0,1\) 浮点数；
- 使用相同的 seed，可以复现相同的结果（可重复性）；
- 参数 a, c, m 用的是一个经典组合，实际是 C 语言 glibc 和 Numerical Recipes 常用参数之一。