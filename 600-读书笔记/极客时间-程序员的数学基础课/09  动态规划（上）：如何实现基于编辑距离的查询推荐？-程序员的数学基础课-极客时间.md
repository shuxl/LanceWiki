你好，我是黄申。

上一篇讲组合的时候，我最后提到了有关文本的关键字查询。今天我接着文本搜索的话题，来聊聊查询推荐（Query Suggestion）的实现过程，以及它所使用的数学思想，动态规划（Dynamic Programming）。

那什么是动态规划呢？在递归那一节，我说过，我们可以通过不断分解问题，将复杂的任务简化为最基本的小问题，比如基于递归实现的归并排序、排列和组合等。不过有时候，我们并不用处理所有可能的情况，只要找到满足条件的最优解就行了。在这种情况下，我们需要在各种可能的局部解中，找出那些可能达到最优的局部解，而放弃其他的局部解。这个寻找最优解的过程其实就是动态规划。

动态规划需要通过子问题的最优解，推导出最终问题的最优解，因此这种方法特别注重子问题之间的转移关系。我们通常把这些子问题之间的转移称为状态转移，并把用于刻画这些状态转移的表达式称为状态转移方程。很显然，找到合适的状态转移方程，是动态规划的关键。

因此，这两节我会通过实际的案例，给你详细解释如何使用动态规划法寻找最优解，包括如何分解问题、发现状态转移的规律，以及定义状态转移方程。

## 编辑距离

当你在搜索引擎的搜索框中输入单词的时候，有没有发现，搜索引擎会返回一系列相关的关键词，方便你直接点击。甚至，当你某个单词输入有误的时候，搜索引擎依旧会返回正确的搜索结果。

![](img/img_1c337d39b48ef544ef811c926c70fbeb.png)

搜索下拉提示和关键词纠错，这两个功能其实就是查询推荐。查询推荐的核心思想其实就是，对于用户的输入，查找相似的关键词并进行返回。而测量拉丁文的文本相似度，最常用的指标是编辑距离（Edit Distance）。

我刚才说了，查询推荐的这两个功能是针对输入有缺失或者有错误的字符串，依旧返回相应的结果。那么，将错误的字符串转成正确的，以此来返回查询结果，这个过程究竟是怎么进行的呢？

由一个字符串转成另一个字符串所需的最少编辑操作次数，我们就叫作编辑距离。这个概念是俄罗斯科学家莱文斯坦提出来的，所以我们也把编辑距离称作莱文斯坦距离（Levenshtein distance）。很显然，编辑距离越小，说明这两个字符串越相似，可以互相作为查询推荐。编辑操作有这三种：把一个字符替换成另一个字符；插入一个字符；删除一个字符。

比如，我们想把 mouuse 转换成 mouse，有很多方法可以实现，但是很显然，直接删除一个“u”是最简单的，所以这两者的编辑距离就是 1。

## 状态转移

对于 mouse 和 mouuse 的例子，我们肉眼很快就能观察出来，编辑距离是 1。但是我们现实的场景中，常常不会这么简单。如果给定任意两个非常复杂的字符串，如何高效地计算出它们之间的编辑距离呢？

我们之前讲过排列和组合。我们先试试用排列的思想来进行编辑操作。比如，把一个字符替换成另一个字符，我们可以想成把 A 中的一个字符替换成 B 中的一个字符。假设 B 中有 m 个不同的字符，那么替换的时候就有 m 种可能性。对于插入一个字符，我们可以想成在 A 中插入来自 B 的一个字符，同样假设 B 中有 m 个不同的字符，那么也有 m 种可能性。至于删除一个字符，我们可以想成在 A 中删除任何一个字符，假设 A 有 n 个不同的字符，那么有 n 种可能性。

可是，等到实现的时候，你会发现实际情况比想象中复杂得多。

首先，计算量非常大。我们假设字符串 A 的长度是 n，而 B 字符串中不同的字符数量是 m，那么 A 所有可能的排列大致在 m^n 这个数量级，这会导致非常久的处理时间。对于查询推荐等实时性的服务而言，服务器的响应时间太长，用户肯定无法接受。

其次，如果需要在字符串 A 中加字符，那么加几个呢，加在哪里呢？同样，删除字符也是如此。因此，可能的排列其实远不止 m^n。

我们现在回到问题本身，其实编辑距离只需要求最小的操作次数，并不要求列出所有的可能。而且排列过程非常容易出错，还会浪费大量计算资源。看来，排列的方法并不可行。

好，这里再来思考一下，其实我们并不需要排列的所有可能性，而只是关心最优解，也就是最短距离。那么，我们能不能每次都选择出一个到目前为止的最优解，并且只保留这种最优解？如果是这样，我们虽然还是使用迭代或者递归编程来实现，但效率上就可以提升很多。

我们先考虑最简单的情况。假设字符串 A 和 B 都是空字符串，那么很明显这个时候编辑距离就是 0。如果 A 增加一个字符 a1，B 保持不动，编辑距离就增加 1。同样，如果 B 增加一个字符 b1，A 保持不动，编辑距离增加 1。但是，如果 A 和 B 有一个字符，那么问题就有点复杂了，我们可以细分为以下几种情况。

我们先来看插入字符的情况。A 字符串是 a1 的时候，B 空串增加一个字符变为 b1；或者 B 字符串为 b1 的时候，A 空串增加一个字符变为 a1。很明显，这种情况下，编辑距离都要增加 1。

我们再来看替换字符的情况。当 A 和 B 都是空串的时候，同时增加一个字符。如果要加入的字符 a1 和 b1 不相等，表示 A 和 B 之间转化的时候需要替换字符，那么编辑距离就是加 1；如果 a1 和 b1 相等，无需替换，那么编辑距离不变。

最后，我们取上述三种情况中编辑距离的最小值作为当前的编辑距离。注意，这里我们只需要保留这个最小的值，而舍弃其他更大的值。这是为什么呢？因为编辑距离随着字符串的增长，是单调递增的。所以，要求最终的最小值，必须要保证对于每个子串，都取得了最小值。有了这点，之后我们就可以使用迭代的方式，一步步推导下去，直到两个字符串结束比较。

刚才我说的情况中没有删除，这是因为删除就是插入的逆操作。如果我们从完整的字符串 A 或者 B 开始，而不是从空串开始，这就是删除操作了。

从上述的过程可以看出，我们确实可以把求编辑距离这个复杂的问题，划分为更多更小的子问题。而且，更为重要的一点是，我们在每一个子问题中，都只需要保留一个最优解。之后的问题求解，只依赖这个最优值。这种求编辑距离的方法就是动态规划，而这些子问题在动态规划中被称为不同的状态。

如果文字描述不是很清楚的话，我这里又画一张表，把各个状态之间的转移都标示清楚，你就一目了然了。

我还是用 mouuse 和 mouse 的例子。我把 mouuse 的字符数组作为表格的行，每一行表示其中一个字母，而 mouse 的字符数组作为列，每列表示其中一个字母，这样就得到下面这个表格。

![](img/img_3f696455617c8a0da422df3cdb64d0cd.png)

这张表格里的不同状态之间的转移，就是状态转移。其中红色部分表示字符串演变（或者说状态转移）的方式以及相应的编辑距离计算。对于表格中其他空白的部分，我暂时不给出，你可以试着自己来推导。

编辑距离是具有对称性的，也就是说从字符串 A 到 B 的编辑距离，和从字符串 B 到 A 的编辑距离，两者一定是相等的。这个应该很好理解。

你可以把刚才那个状态转移表的行和列互换一下，再推导一下，看看得出的编辑距离是否还是 1。我现在从理论上解释下这一点。这其实是由编辑距离的三种操作决定的。比如说，从字符串 A 演变到 B 的每一种操作，都可以转换为从字符串 B 演变到 A 的某一种操作。

![](img/img_1824ca86219e0f05591aa48fe7f6dee8.jpg)

所以说，从字符串 A 演变到 B 的每一种变化方式，都可以找到对应的从字符串 B 演变到 A 的某种方式，两者的操作次数一样。自然，代表最小操作次数的编辑距离也就一样了。

## 小结

我今天介绍了用于查询推荐的编辑距离。编辑距离的定义很好理解，不过，求任意两个字符串之间的编辑距离可不是一件容易的事情。我先尝试用排列来分析问题，发现这条路走不通，而后我们仍然使用了化繁为简的思路，把编辑距离的计算拆分为 3 种情况，并建立了子串之间的联系。

你不要觉得这样的分析过程比较繁琐，我想说的是，学数学固然是为了得到结果，但是学习的过程，是要学会解决问题的方法和思路。比如面对一个问题的时候，你可能不知道用什么方法来解决，但是你可以尝试用我们学过的这些基础思想去分析，去比对，在这个分析的过程中去总结这些方法的使用规律，久而久之，你就能摸索出自己解决问题的套路。

比如说，动态规划虽然也采用了把问题逐步简化的思想，但是它和基于递归的归并排序、排列组合等解法有所不同。能够使用动态规划解决的问题，通常只关心一个最优解，而这个最优解是单调改变的，例如最大值、最小值等等。因此，动态规划中的每种状态，通常只保留一个当前的最优解，这也是动态规划效率比较高的原因。

![](img/img_f37da4a1ef98494dea70016b90922594.jpg)

## 思考题

理解了动态规划法和状态转移之后，你觉得根据编辑距离来衡量字符串之间的相似程度有什么局限性？你有什么优化方案吗？

欢迎在留言区交作业，并写下你今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。

![](img/img_d0880927e2a522a038be2d04bf19dfe4.png)

动态规划：编辑距离与字符串相似度 本文介绍了动态规划在解决编辑距离和衡量字符串相似度方面的实际应用。通过编辑距离的定义和计算过程，读者可以深入了解动态规划的核心思想和具体应用。文章以编辑距离为例，详细介绍了动态规划的分解问题、状态转移规律和状态转移方程的求解过程。通过生动的例子和清晰的逻辑，读者可以领略动态规划的高效计算方法，以及编辑距离的对称性特点。此外，文章还提出了思考题，引导读者思考编辑距离衡量字符串相似度的局限性和优化方案。总的来说，本文为读者提供了一份深入浅出的技术指南，帮助他们快速了解动态规划的应用特点和解决问题的方法思路。