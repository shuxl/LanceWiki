Redis 数据类型。String（字符、整数、浮点数），List（列表），Set（无序集合，计算交集、并集、差集），Zset（有序集合），Hash（结构化对象）

Redis 线程模型。文件事件处理器（多个套接字、IO多路复用、文件事件分派器、事件处理器）=单线程。IO多路 监听 多个 套接字 ，达成高性能网络通信。
Redis 事务。MULTI（开始），ExEC（事务执行），WATCH等命令集合。不保证原子（失败不回滚已经执行的命令），只保证隔离（单线程）。
Redis 哨兵。功能：集群监控（master、salve），消息通知（故障），故障转移（master故障，转salve），配置中心（故障转移后，通知client新master）。
Redis 服务端Sharding技术，slot（槽），16384个槽。
    请求发送到任意节点，接受的节点路由到实际的节点上执行。1、数据使用哈希的方式分配到各个哈希槽区间（16384个槽，对应2K的压缩16K的bitmap压缩）；2、数据被写入主节点，在同步到从节点（数据主从分片在不同节点，可配置阻塞同步），3、读数据时，key不在当前节点，使用转向指令

Redis 分布式锁。SETNX设置，DEL命令删除。SET key value [EX seconds] [PX milliseconds] [NX|XX] 等效于SETNX，SETEX，PSETEX
    避坑方式：setnx和expre非原子性，2.6.12版本后可以支持set加超时时间；
            超时释放，被B拿到锁，执行完成后A释放了B的锁。del锁之前，做个判断验证线程Id。验证和释放采用lua脚本实现。
            用守护线程给锁在即将超时时续命。

Redis 缓存雪崩。缓存同时失效。设置随机过期时间；加锁排队；标记失效缓存，主动更新缓存。
Redis 缓存穿透。无效key，无法缓存。接口层拦截非法key；缓存此类key的null，30秒；布隆过滤器，缓存一定不存在的hash到一个bitmap上
Redis 缓存击穿。缓存中未缓存某些理论存在的key（比如到期了），一般指高请求同一数据。数据不过期；互斥锁

Resis 数据不丢失。持久化到磁盘。三种方式：AOF日志（文件追加，写后日志），RDB快照（内存数据，二进制写入磁盘），Redis4.0使用混合模式
    AOF ：数据丢失风险；主线程写操作，会阻塞其它线程。
    RDB：save，bgsave两种命令。save是主线成执行，会阻塞；bgsave是子线程，redis 默认配置。
        bgsave 实现主线程读写不影响的机制：如果主线程执行读操作，则主线程和bgsave 子进程互相不影响；如果主线程执行写操作，则被修改的数据会复制一份副本，然后bgsave子进程会把该副本数据写入 RDB 文件，在这个过程中，主线程仍然可以直接修改原来的数据。

Redis 高可用实现方式：主从复制，哨兵模式，redis集群。
    主从复制：类似于mysql；哨兵模式：因为哨兵模式做到了可以监控主从服务器，并且提供自动容灾恢复的功能；Redis Cluster（集群）。
    集群和哨兵混用原因。哨兵模式归根节点还是主从模式，在主从模式下我们可以通过增加salve节点来扩展读并发能力，但是没办法扩展写能力和存储能力，存储能力只能是master节点能够承载的上限。所以为了扩展写能力和存储能力，我们就需要引入集群模式。
    集群中master节点如何对外提供服务的。
        Redis Cluster将自己分成了16384个Slot（槽位），哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中，具体执行过程分为两大步。
            + 根据键值对的 key，按照 CRC16 算法计算一个 16 bit 的值。
            + 再用 16bit 值对 16384 取模，得到0~16383 范围内的模数，每个模数代表一个相应编号的哈希槽

槽迁移过程
    https://blog.csdn.net/shijinghan1126/article/details/108256089