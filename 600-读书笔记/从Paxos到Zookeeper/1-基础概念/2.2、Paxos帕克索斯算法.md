
# 1 算法解决问题
+ 解决分布式系统中，发生当即、网络异常时，数据不一致问题
+ 快速且正确的在集群内部对某个数据的值达成一致，并且保证不论发送任何异常，都不会破坏整个系统的一致性
# 2 算法详解
> Paxos核心是一个一致性算法
## 2.2 算法解决问题描述
假设有一组可以提出提案的进程集合，一致性算法需要保证以下几点：
+ 在这些被提出的提案中，只有一个会被选定
+ 如果没有提案被提出，那么就会有有被选定的提案
+ 当一个提案被选定后，进程应该可以获取被选定的提案信息

对于一致性来说，安全性需求如下：
+ 只有被提出的提案才能被选定
+ 只能有一个值被选定
+ 如果某个进程认为某个提案被选定了，那么这个提案必须是真的被选定的那个

## 2.2算法参与的角色说明
+ Proposer
+ Acceptor
+ Learner

角色的工作情况以及一致性算法运行过程中会出现的问题假设
+ 每个参与者以任意的速度执行，可能会出错停止、重启。同时，即使一个提案被选定后，所有参与者也都有可能失败或重启，需要参与者可以记录过程信息，以确定最终值
+ 消息在传输过程中可能会出现不可预知的延迟，也可能会重复或丢失，但消息不回被损坏（即消息内容不会被篡改）

## 2.3算法推导
### 2.3.1 如何选定提案
最简单的提案实现方式：选定一个提案最简单的方式是只有一个Acceptor，Proposer只能发送提案给到该Acceptor，Acceptor会选择它接受到的第一个提案作为被选定的提案。    

但是，只要这个Acceptor出现问题，系统将无法继续工作。

因此，需要多个Acceptor来避免Acceptor的单点问题。引出新的问题，多个Acceptor的情况下，如何进行提案的选取？

**Proposer 向一个Acceptor集合发送提案，Acceptor集合每个Acceptor都可能会批准提案（Accept），当足够多的Acceptor批准这个提案时，认为改提案被选定了。**
+ Acceptor集合为整个Acceptor集合的一个子集，并且这个集合数量为大多数成员。因为任意两个包含大多数的集合，至少有一个公共成员
+ 每个Acceptor最多只能批准一个提案。保证只有一个提案被选定

### 2.3.2 选定提案的关键法则以及推导
假设没有消息失败和消息丢失，只有一个提案被提出，仍然可以选出一个提案，需要出现以下法则做保障：
+ P1：一个Acceptor必须批准它收到的第一个提案
-----
P1推演，引出了另外一个问题：如果多个提案被同步Proposer同时提出，此时每个Acceptor都批准了它收到的第一个提案，但没有一个提案是由多数人都批准的。如下图的表格：
| Proposer | Propose | Acceptor1 |Acceptor2 |Acceptor3 |Acceptor4 |
| -- | -- | -- | -- | -- | -- |
| Proposer1 | V1 | Accept | | | |
| Proposer2 | V2 |  | Accept| | |
| Proposer3 | V3 |  | | Accept| |
| Proposer4 | V4 |  | | | Accept |

上表中出现每个Proposer提议被一个Acceptor同意，此时无法选出任何提案。

即使只有两个提案被提出，如果提案都被差不多一半的Acceptor批准，此时即使只有个Acceptor出错，都有可能导致无法确定最终提案。如下表中，Acceptor5异常：
| Proposer | Propose | Acceptor1 |Acceptor2 |Acceptor3 |Acceptor4 |Acceptor5(Error) |
| -- | -- | -- | -- | -- | -- | -- |
| Proposer1 | V1 | Accept | Accept | | | |
| Proposer2 | V2 |  | | Accept | Accept | Accept(Error) |

上表中虽然正常情况下应该V2被3票通过，但是有个Acceptor异常，也会导致投票失败。

----
基于上面的问题，在P1的基础上加P2的新规则：一个提案被选定需要由半数以上的Acceptor批准的需求，同时暗示着一个Acceptor必须能够批准不止一个提案。

此处需要将提案格式变为“(编号，Value)”，编号由一个外部生成连续序号的组件来完成。