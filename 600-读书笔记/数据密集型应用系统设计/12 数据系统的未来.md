+ 未来的系统应该是什么样子？
+ 探索如何设计比今天（如何构建可靠、可扩展和可维护的应用和系统）更好的应用程序
# 1 数据集成
面对不同数据使用场景，基于不同数据存储方案的优缺点，进行讨论
## 1.1 采用派生数据来组合工具
背景：每种数据库支持的使用模式不同，比如相对于关系型数据，有些数据库对搜索支持更友好
### 1.1.1 为何需要数据流
对主数据系统和派生系统进行双写，会出现不可描述的问题。这时在主存储系统中写，派生系统使用数据流的方式同步数据，就很值得推荐
### 1.1.2 派生数据与分布式事务
派生数据的生成，通常不用分布式事务来处理，分布式事务的容错和性能往往不够好。
相对于分布式事务，基于日志的派生数据是集成不同数据系统的最有前途的方法。
后续章节，作者还会介绍介于分布式事务和日志一步系统之外的中间方案。
### 1.1.3 全序的局限
首先全序对小系统来说是完全可行的（主从复制）。但是对更复杂的负载时，存在许多瓶颈：
+ 大多数情况下，构建一个完全有序的日志需要所有事件都通过一个主节点来决得排序。但是事件吞吐量大于单台节点的处理上限，则需要将其分区到多台节点上，这就使两个不同分区的事件顺序变得不明确了
+ 如果服务器分布在多个不同地理位置的数据中心，通常每个数据中心都有独立的主节点（多主节点）。此时会出现两个不同数据中心的事件顺序不确定
+ 微服务架构下，不同服务同时持久化数据库时，事件顺序也无法保障。
+ 客户端可以离线处理数据时，在数据合并时，事件顺序也无法保障
在以上问题出现的时候，需要有一个决定事件的全序关系（全系关系广播）。但是对突破单节点限制的广域地理环境分布的共识算法，还是一个待研究的开放性问题
### 1.1.4 排序事件以捕获因果关系
如果事件之间无因果关系，不支持全序，不是个大问题。
但是有些场景，需要我们支持时又有哪些思路可以启用呢？
+ 逻辑时间戳可以在无协调者的情况下提供全序关系。但是，它们需要接收者出处理那些乱序的事件，并且需要额外的元数据
+ 记录一条事件来标记事件发生前的系统状态，并给该事件一个唯一的标识符，那么后续事件都可以通过引用该事件的标识符来记录因果关系。（后续在“读操作也是事件”中重谈）
+ 冲突解决算法，可以处理异常顺序的事件。但是前提是行为不能外部可见（如向用户发送通知）
也许将来程序开发模式发送变化，使得因果关系被有效的铺货，派生状态得到正确的维护，而不会强制所有时间必须通过全序广播
## 1.2 批处理和流处理集成
使用批处理和流处理的输出来派生数据，生成不同的数据系统的派生数据集。
批处理和流处理的特性（无状态的函数式编程逻辑），非常适合数据集成

# 2 分拆数据库
未来的系统，可能需要面临的问题是，如何分拆各种数据库系统，并把它集成到一个大的系统中来。
问题：这节的核心观点可能是想说，基于分离式数据库来引入在分离式数据库下的系统可能长啥样子
## 2.1 编排多种数据存储技术
那么如何编排各种数据存储技术呢？
比如使用批处理和流处理起来构建派生数据系统。
作者认为整个组织的数据流变得像一个巨大的数据库，不同的存储和处理工具最终组合成一个紧密结合的系统。而这个系统的组合方式会有两种途径：
1. 联合数据库：统一读端。把各种底层存储引擎和处理方法包装起来，对外提供统一的查询接口
2. 分离式数据库：统一写端。将数据写入到多个存储系统数据库，同时保障正确性（就算发生故障，也能保障所有的存储系统写入正确）。统一写端的分离式数据库，相对于统一读端，更难实现
### 2.1.1 分离式如何工作
作者认为，传统的同步写依赖于跨异构存储系统的分布式事务，是个错误的解决方案（作者认为分布式事务只适合单个存储系统内或流处理系统内的事务）。而当数据跨越不同的技术边界时，具有幂等写入的异步事件日志是一种更加健壮和可行的方法。
> 幂等异步如何做事务回退呢？这里的异步，应该是等到事务提交后再进行下一阶段的处理，那么就没有所谓的回退了吧。

基于日志集成的优势是各个组件之间松耦合，两方面的体现：
1. 在系统级别，异步事件流使整个系统在应对哥哥组件的中断或性能下降时表现更佳稳健。消费者和生产者之间运行互不干扰，而分布式事务的同步往往会将各个系统的本地故障扩大到整个大系统，导致大规模故障。
2. 对开发人员来说，不同团队的维护是独立的，边界也是清晰的
### 2.1.2 分离式与集成式系统
集成式系统（单一软件系统）遇到瓶颈时，可以试着找一种新的技术来满足需求，即将系统升级为分离式系统。没有单一的软件能满足所有的需求

## 2.2 围绕数据流设计应用系统
