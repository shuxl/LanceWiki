+ 测试类，使用两个互相引用的类学生Studeng、教师ClassRoom，进行构建测试
	+ 发现Spring默认支持循环依赖
	+ 继续测试，将*allowCricularRefrences*设置为false后，启动异常
	+ 进一步分析代码，查看*allowCricularRefrences*的引用点doCreateBean方法
	+ 然后就在代码里面出不来了，我觉得我可以先去网上查一下其他资料
	+ 从百度的DS——R1模型上得出的结论比较适中，我觉得可以把它记录下来
# 1 DeepSeek解答
Spring 通过‌**三级缓存**机制‌解决单例模式下的属性注入循环依赖问题，具体实现流程如下：
## 1.1 循环依赖的定义与场景
1. 定义‌
多个 Bean 之间存在直接或间接的依赖关系，形成环形调用链。例如：
	+  A 依赖 B，B 依赖 C，C 依赖 A（间接依赖）
	+  A 依赖 B，B 直接依赖 A（直接依赖）‌
2. 支持场景‌
	+ 单例模式‌的 ‌Setter/Field 属性注入‌（非构造器注入）‌
	- 不支持的情况‌：
		- 构造器注入（初始化阶段无法提前暴露 Bean）‌
		- Prototype 作用域的 Bean（无法缓存中间状态）‌

## 1.2 三级缓存机制

Spring 通过以下三个缓存存储不同状态的 Bean 实例：

| 缓存级别   | 名称                      | 存储内容                           |
| ------ | ----------------------- | ------------------------------ |
| ‌一级缓存‌ | `singletonObjects`      | 完全初始化完成的单例 Bean                |
| ‌二级缓存  | `earlySingletonObjects` | 已实例化但未完成属性注入的早期 Bean           |
| ‌三级缓存  | `singletonFactories`    | 生成 Bean 的工厂对象（ObjectFactory） ‌ |
## 1.3 循环依赖解决流程（以 A→B→A 为例）
1. 创建 Bean A‌
	+ 实例化‌：通过反射创建 A 的实例（此时属性均为默认值）。
	+  存入三级缓存‌：将 A 的工厂对象（ObjectFactory）存入 singletonFactories‌。
2. 填充 A 的属性（发现依赖 B）‌
	- 尝试从一级缓存获取 B，未找到则触发 B 的创建流程‌。
3. 创建 Bean B‌
	- 实例化 B‌：同样通过反射创建 B 的实例。
	- 存入三级缓存‌：将 B 的工厂对象存入 singletonFactories‌。
4. 填充 B 的属性（发现依赖 A）‌
	- 获取 A 的早期引用‌：
		1. 从三级缓存获取 A 的 ObjectFactory，生成 A 的早期对象（若需要 AOP 代理则提前生成代理对象）。
		2. 将 A 的早期对象移至二级缓存 earlySingletonObjects，并清除三级缓存中的 A‌。
	- 将 A 的早期对象注入到 B 中，完成 B 的初始化。
	- B 初始化完成‌：B 被移入一级缓存 singletonObjects‌。
5. 完成 A 的初始化‌
	- 将 B 的完整实例注入到 A 中。
	- 执行 A 的初始化方法（如 @PostConstruct）。
	- A 初始化完成‌：A 从二级缓存移至一级缓存‌。
## 1.4 核心设计要点
1. 提前暴露对象‌
	实例化后立即通过三级缓存暴露早期引用，打破循环依赖的僵局‌。
2. **AOP 代理处理**‌
	三级缓存的 ObjectFactory 可在获取早期引用时动态生成代理对象，确保依赖注入的正确性‌。
3. 线程安全‌
	**一级缓存使用 ConcurrentHashMap，二级、三级缓存通过同步代码块保证线程安全‌。**
## 1.5 流程图解
```
创建A → 实例化A → 存入三级缓存 → 注入B  
↓  
创建B → 实例化B → 存入三级缓存 → 注入A  
↓  
从三级缓存获取A的工厂 → 生成早期A → 存入二级缓存 → 完成B的初始化  
↓  
将B注入A → 完成A的初始化 → 移入一级缓存  
```
通过这一机制，Spring 在**单例模式**下高效解决了属性注入的循环依赖问题，但需注意构造器注入和原型模式下的限制‌。

## 1.6 为何构造器注入和Prototype的作用域的Bean的循环依赖会失败
### 1.6.1 构造器注入的依赖问题
-   **实例化阶段的依赖冲突**  
    构造器注入要求在实例化 Bean 时**立即完成依赖注入**。例如，创建 Bean A 需先实例化其构造器参数 Bean B，而创建 Bean B 又需要 Bean A，导致双方均无法完成实例化，形成死锁。
    
-   **三级缓存机制的失效**  
    Spring 的三级缓存（`singletonFactories`、`earlySingletonObjects`、`singletonObjects`）仅在 Bean **实例化后、属性注入前**暴露早期引用。构造器注入发生在实例化阶段，此时 Bean 尚未存入缓存，无法通过提前引用打破循环。
    
-   **异常触发机制**  
    Spring 在实例化过程中会将 Bean 标识符存入“当前创建 Bean 池”（`singletonsCurrentlyInCreation`）。当检测到循环依赖时，直接抛出 `BeanCurrentlyInCreationException`，而非尝试解决。
### 1.6.2 Prototype 作用域 Bean 的循环依赖问题
-   **无缓存机制支持**  
    Prototype Bean **每次请求均生成新实例**，而 Spring 的三级缓存仅针对单例 Bean 设计。由于无法缓存中间状态（如未完成初始化的早期对象），依赖注入时无法复用已创建的实例。
    
-   **生命周期管理差异**  
    Prototype Bean 的销毁不由 Spring 管理，依赖注入时需实时创建完整对象。若存在循环依赖（如 A→B→A），每次注入会触发新实例的创建，导致无限递归，最终抛出异常。
    
-   **动态代理的局限性**  
    即使通过 `ObjectFactory` 或 `Provider` 延迟获取 Prototype Bean，仍需在每次注入时生成新实例，无法像单例模式通过三级缓存提前返回代理对象或原始对象。

### 1.6.3 两类问题的共性限制

| 限制维度    | 构造器注入                            | Prototype Bean |
| ------- | -------------------------------- | -------------- |
| 依赖解决阶段  | 实例化阶段（过早）                        | 属性注入阶段（无法复用缓存） |
| 三级缓存适用性 | 完全失效                             | 不适用            |
| 典型异常    | BeanCurrentlyInCreationException | 同左或栈溢出错误       |
| 解决方案    | 重构代码，改用 Setter/字段注入              | 改用单例模式或手动管理依赖链 |
### 1.6.4 总结

Spring 无法解决这两类循环依赖的核心原因在于：
1.  **构造器注入**强制在实例化阶段完成依赖绑定，无法通过缓存提前暴露对象。
2.  **Prototype Bean**缺乏缓存机制支持，且每次依赖注入需生成新实例，导致无法复用中间状态。  
    **规避方案**：优先使用单例作用域 + Setter/字段注入，或在设计阶段避免循环依赖。
